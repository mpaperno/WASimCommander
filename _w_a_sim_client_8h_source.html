<!-- HTML header for doxygen 1.9.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WASimCommander: src/include/client/WASimClient.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Logo.png" title="WASimCommander - Remote access to the Microsoft Flight Simulator 2020 Gauge API."/></td>
  <td id="projectalign">
   <div id="projectname"><!-- WASimCommander --><span id="projectnumber">&#160;v1.3.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/mpaperno/WASimCommander" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z" fill="url(#gradient)"></path>
    <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
    <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
    <linearGradient id="gradient" x1="0.5" x2="0.5" y1="0" y2="1">
        <stop class="first-stop" offset="0%"></stop>
        <stop class="last-stop" offset="100%"></stop>
    </linearGradient>
    </svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_w_a_sim_client_8h_source.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">WASimClient.h</div></div>
</div><!--header-->
<div class="contents">
<a href="_w_a_sim_client_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">/*</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment">This file is part of the WASimCommander project.</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment">https://github.com/mpaperno/WASimCommander</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment"></span> </div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment">COPYRIGHT: (c) Maxim Paperno; All Rights Reserved.</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment"></span> </div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment">This file may be used under the terms of either the GNU General Public License (GPL)</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment">or the GNU Lesser General Public License (LGPL), as published by the Free Software</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span><span class="comment">Foundation, either version 3 of the Licenses, or (at your option) any later version.</span></div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="comment"></span> </div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="comment">This program is distributed in the hope that it will be useful,</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="comment">but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="comment">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="comment">GNU General Public License for more details.</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="comment"></span> </div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="comment">Copies of the GNU GPL and LGPL are included with this project</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="comment">and are available at &lt;http://www.gnu.org/licenses/&gt;.</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="comment">*/</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span> </div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="preprocessor">#pragma once</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span> </div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="preprocessor">#include &lt;Windows.h&gt;</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span> </div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="preprocessor">#include &quot;<a class="code" href="_w_a_sim_commander_8h.html">WASimCommander.h</a>&quot;</span></div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="preprocessor">#include &quot;client/exports.h&quot;</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="preprocessor">#include &quot;client/enums.h&quot;</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="preprocessor">#include &quot;client/structs.h&quot;</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="comment"></span> </div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="comment">/// \file</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span><span class="comment">/// \def WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="comment">/// Define with value of 0 (zero) to invoke all callbacks consecutively, using a mutex lock. Default is (possible) concurrent invocation. Callbacks may still arrive from different threads. \relates WASimClient</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span><span class="comment"></span><span class="preprocessor">#ifndef WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno"><a class="line" href="_w_a_sim_client_8h.html#a322d2a2abb9d43f7c3f0a6ddd9d3adee">   41</a></span><span class="preprocessor">  #define WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS  1</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="comment"></span> </div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="comment">/// WASimCommander::Client namespace.</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span><span class="comment">/// Defines/declares everything needed to interact with the _WASimCommander Client API_, including the WASimClient class itself.</span></div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span><span class="comment"></span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_w_a_sim_commander_1_1_client.html">WASimCommander::Client</a></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span>{</div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span> </div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="comment">//----------------------------------------------------------------------------</span></div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="comment">//        Constants</span></div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span><span class="comment">//----------------------------------------------------------------------------</span></div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment"></span> </div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment">/// \name Return result values</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span><span class="comment">/// \{</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno">   55</span><span class="comment"></span><span class="preprocessor">#ifndef E_NOT_CONNECTED</span></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#aaed3e026d9bf1ef254d300587e4dbdb5">   56</a></span><span class="keyword">static</span> <span class="keyword">const</span> HRESULT <a class="code hl_variable" href="namespace_w_a_sim_commander_1_1_client.html#aaed3e026d9bf1ef254d300587e4dbdb5">E_NOT_CONNECTED</a> = <span class="comment">/*ERROR_NOT_CONNECTED*/</span> 2250L | (<span class="comment">/*FACILITY_WIN32*/</span> 7 &lt;&lt; 16) | 0x80000000; <span class="comment">///&lt; Error result: server not connected</span></div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno">   57</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span><span class="preprocessor">#ifndef E_TIMEOUT</span></div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#a23b8cf1733162a35a02159b38c3af217">   59</a></span><span class="keyword">static</span> <span class="keyword">const</span> HRESULT <a class="code hl_variable" href="namespace_w_a_sim_commander_1_1_client.html#a23b8cf1733162a35a02159b38c3af217">E_TIMEOUT</a>       = <span class="comment">/*ERROR_TIMEOUT*/</span>       1460L | (<span class="comment">/*FACILITY_WIN32*/</span> 7 &lt;&lt; 16) | 0x80000000;  <span class="comment">///&lt; Error result: timeout communicating with server.</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span><span class="preprocessor">#endif</span><span class="comment"></span></div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno">   61</span><span class="comment">/// \}</span></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="comment">/// Starting ID range for &quot;Custom Key Events&quot; for use with `registerCustomKeyEvent()` generated IDs.</span></div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno">   64</span><span class="comment">/// (This corresponds to the value of `1 + THIRD_PARTY_EVENT_ID_MAX` constant from SimConnect SDK header file &#39;MSFS/Legacy/gauges.h&#39;.)</span></div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#ab1bd21185e813b2cdb9622bb49b34ff8">   65</a></span><span class="comment"></span><span class="keyword">static</span> <span class="keyword">const</span> uint32_t <a class="code hl_variable" href="namespace_w_a_sim_commander_1_1_client.html#ab1bd21185e813b2cdb9622bb49b34ff8">CUSTOM_KEY_EVENT_ID_MIN</a> = 0x00020000;</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span> </div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span> </div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span><span class="comment">//----------------------------------------------------------------------------</span></div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span><span class="comment">//       Callback Types</span></div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span><span class="comment">//----------------------------------------------------------------------------</span></div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span> </div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#adf721d1a2e6d07f9b0d8b8557408cf6f">   72</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#adf721d1a2e6d07f9b0d8b8557408cf6f">clientEventCallback_t</a> = std::function&lt;<span class="keywordtype">void</span> __stdcall(<span class="keyword">const</span> <a class="code hl_struct" href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_client_event">ClientEvent</a> &amp;)&gt;;   <span class="comment">///&lt; Callback function for Client events. \sa WASimClient::setClientEventCallback()</span></div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#a58cba5c3dda6fb308904f9b238c4eef8">   73</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a58cba5c3dda6fb308904f9b238c4eef8">listResultsCallback_t</a> = std::function&lt;<span class="keywordtype">void</span> __stdcall(<span class="keyword">const</span> <a class="code hl_struct" href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_list_result">ListResult</a> &amp;)&gt;;    <span class="comment">///&lt; Callback function for delivering list results, eg. of local variables sent from Server. \sa WASimClient::setListResultsCallback()</span></div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#a4e101c8c07197b490c3d1e2929f080a5">   74</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a4e101c8c07197b490c3d1e2929f080a5">dataCallback_t</a> = std::function&lt;<span class="keywordtype">void</span> __stdcall(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_data_request_record.html">DataRequestRecord</a> &amp;)&gt;;    <span class="comment">///&lt; Callback function for subscription result data. \sa WASimClient::setDataCallback()</span></div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#a34b741f7fd40e861e389ae776b3c7de3">   75</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a34b741f7fd40e861e389ae776b3c7de3">logCallback_t</a> = std::function&lt;<span class="keywordtype">void</span> __stdcall(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_log_record.html">LogRecord</a> &amp;, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051">LogSource</a>)&gt;;  <span class="comment">///&lt; Callback function for log entries (from both Client and Server). \sa WASimClient::setLogCallback()</span></div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno"><a class="line" href="namespace_w_a_sim_commander_1_1_client.html#a68e29e00dcabb749657f695cf8f2c246">   76</a></span>  <span class="keyword">using </span><a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a68e29e00dcabb749657f695cf8f2c246">commandCallback_t</a> = std::function&lt;<span class="keywordtype">void</span> __stdcall(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;)&gt;;           <span class="comment">///&lt; Callback function for commands sent from server. \sa WASimClient::setCommandResultCallback(), WASimClient::setResponseCallback()</span></div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span> </div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno">   78</span> </div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="comment">// -------------------------------------------------------------</span></div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span><span class="comment">//       WASimClient</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span><span class="comment">// -------------------------------------------------------------</span></div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span><span class="comment"></span> </div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span><span class="comment">  /// WASimCommander Client implementation. Handles all aspects of communication with the WASimCommander Server WASM module.</span></div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">   84</a></span><span class="comment"></span>  <span class="keyword">class </span>WSMCMND_API <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a></div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span>  {</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span>  <span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span><span class="comment">    /// Instantiate the client with a unique ID and optional configuration file path.</span></div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span><span class="comment">    /// \param clientId This ID must not be shared with any other Client accessing the Server.</span></div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span><span class="comment">    ///   The ID is also used as the client name by converting it to a 8-character hexadecimal string. For example 3235839725 = &quot;C0DEFEED&quot;. Get creative.</span></div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span><span class="comment">    ///   The client name is used as a key component of data exchange with the simulator engine.</span></div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span><span class="comment">    ///   The ID cannot be zero, and server connections will fail if it is. It can also be set/changed after class creation using the `setClientId()` method, but before connecting to the server.</span></div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span><span class="comment">    /// \param configFile Optionally provide the path to a configuration file for reading initial startup settings. By default the client will look for a `client_conf.ini` file in the current working directory.</span></div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span><span class="comment">    ///   The parameter value may include the file name (with extension), or be only a file system path, in which case the default file name of &quot;client_conf.ini&quot; will be appended.</span></div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span><span class="comment"></span>    <span class="keyword">explicit</span> <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a>(uint32_t clientId, <span class="keyword">const</span> std::string &amp;configFile = std::string());<span class="comment"></span></div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span><span class="comment">    /// Any open network connections are automatically closed upon destruction, though it is better to close them yourself before deleting the client.</span></div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span><span class="comment"></span>    <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">~WASimClient</a>();</div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span><span class="comment"></span> </div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span><span class="comment">    /// \name Network actions, status, and settings</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span><span class="comment"></span> </div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span>    <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_client.html#afd4f3e93b7e8dc26cd2d99ad61584521">ClientStatus</a> status() <span class="keyword">const</span>;  <span class="comment">///&lt; Get current connection status of this client. \sa WASimCommander::Client::ClientStatus</span></div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span>    <span class="keywordtype">bool</span> isInitialized() <span class="keyword">const</span>;   <span class="comment">///&lt; Check if simulator network link is established. \sa connectSimulator()</span></div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span>    <span class="keywordtype">bool</span> isConnected() <span class="keyword">const</span>;     <span class="comment">///&lt; Check WASimCommander server connection status.  \sa connectServer()</span></div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>    uint32_t clientVersion() <span class="keyword">const</span>;  <span class="comment">///&lt; Return the current WASimClient version number. Version numbers are in &quot;BCD&quot; format:  `MAJOR &lt;&lt; 24 | MINOR &lt;&lt; 16 | PATCH &lt;&lt; 8 | BUILD`, eg: `1.23.45.67 = 0x01234567`</span></div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span>    uint32_t serverVersion() <span class="keyword">const</span>;  <span class="comment">///&lt; Return the version number of the last-connected, or successfully pinged, WASimModule (sever), or zero if unknown. See `clientVersion()` for numbering details.</span></div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span><span class="comment"></span> </div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span><span class="comment">    /// Initialize the simulator network link and set up minimum necessary for WASimCommander server ping or connection. Uses default network SimConnect configuration ID.</span></div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span><span class="comment">    /// \param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.</span></div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span><span class="comment">    /// \return `S_OK` (0) - Success;\n</span></div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span><span class="comment">    ///  `E_FAIL` (0x80004005) - General failure (most likely simulator is not running);\n</span></div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span><span class="comment">    ///  `E_TIMEOUT` (0x800705B4) - Connection attempt timed out (simulator/network issue);\n</span></div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span><span class="comment">    ///  `E_INVALIDARG` (0x80070057) - The Client ID set in constructor is invalid (zero) or the SimConnect.cfg file did not contain the default config index (see `networkConfigurationId()` ) ;</span></div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span><span class="comment">    /// \note This method blocks until either the Simulator responds or the timeout has expired.</span></div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span><span class="comment">    /// \sa defaultTimeout(), setDefaultTimeout(), networkConfigurationId() setNetworkConfigurationId(), connectSimulator(int, uint32_t)</span></div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span><span class="comment"></span>    HRESULT connectSimulator(uint32_t timeout = 0);<span class="comment"></span></div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span><span class="comment">    /// Initialize the simulator network link and set up minimum necessary for WASimCommander server ping or connection. This overload allows specifying a SimConnect configuration ID and optional timeout value.</span></div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span><span class="comment">    /// \param networkConfigId SimConnect is used for the network layer. Specify the SimConnect.cfg index to use, or -1 (default) to force a local connection.</span></div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span><span class="comment">    /// \param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.</span></div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span><span class="comment">    /// \return `S_OK` (0) - Success;\n</span></div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span><span class="comment">    ///  `E_FAIL` (0x80004005) - General failure (most likely simulator is not running);\n</span></div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span><span class="comment">    ///  `E_TIMEOUT` (0x800705B4) - Connection attempt timed out (simulator/network issue);\n</span></div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span><span class="comment">    ///  `E_INVALIDARG` (0x80070057) - The Client ID set in constructor is invalid (zero) or the SimConnect.cfg file did not contain the config index requested in the `simConnectConfigId` parameter;</span></div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span><span class="comment">    /// \note This method blocks until either the Simulator responds or the timeout has expired. \sa connectSimulator(), defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span><span class="comment"></span>    HRESULT connectSimulator(<span class="keywordtype">int</span> networkConfigId, uint32_t timeout = 0);<span class="comment"></span></div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span><span class="comment">    /// Shut down all network connections (and disconnect WASimCommander server if connected).</span></div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span><span class="comment">    /// After calling this method, one must call `connectSimulator()`/`connectServer()`/`pingServer()` again before any other commands.</span></div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span><span class="comment"></span>    <span class="keywordtype">void</span> disconnectSimulator();</div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span><span class="comment"></span> </div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span><span class="comment">    /// Check if WASimCommander Server exists (Simulator running, the WASIM module is installed and working). Returns server version number, or zero if server did not respond.\n</span></div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span><span class="comment">    /// This will implicitly call `connectSimulator()` first if it hasn&#39;t already been done, using the default network configuration settings. Zero will be returned if the connection could not be established.</span></div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span><span class="comment">    /// \param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.</span></div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span><span class="comment">    /// \return Server version number, or zero (`0`) if server (or simulator) didn&#39;t respond within the timeout period.</span></div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span><span class="comment">    /// \note This method blocks until either the Server responds or the timeout has expired. \sa defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span><span class="comment"></span>    uint32_t pingServer(uint32_t timeout = 0);</div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span><span class="comment"></span> </div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span><span class="comment">    /// Connect to WASimCommander server.</span></div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span><span class="comment">    /// This will implicitly call \c connectSimulator() first if it hasn&#39;t already been done, using the default network configuration setting.</span></div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span><span class="comment">    /// \param timeout Maximum time to wait for response, in milliseconds. Zero (default) means to use the `defaultTimeout()` value.</span></div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span><span class="comment">    /// \return `S_OK` (0) - Success.\n</span></div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span><span class="comment">    ///  `E_FAIL` (0x80004005) - General failure (most likely simulator is not running).\n</span></div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span><span class="comment">    ///  `E_TIMEOUT` (0x800705B4) - Connection attempt timed out (simulator/network issue or WASimCommander WASM module is not installed/running).\n</span></div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span><span class="comment">    ///  `E_INVALIDARG` (0x80070057) - The Client ID set in constructor is invalid (zero) or the SimConnect.cfg file did not contain the default config index.</span></div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span><span class="comment">    /// \note This method blocks until either the Server responds or the timeout has expired. \sa defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span><span class="comment"></span>    HRESULT connectServer(uint32_t timeout = 0);<span class="comment"></span></div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span><span class="comment">    /// Disconnect from the WASimCommander server. This does _not_ close the Simulator network connection (use \c disconnectSimulator() to do that or both at once).</span></div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span><span class="comment"></span>    <span class="keywordtype">void</span> disconnectServer();</div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span><span class="comment"></span> </div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span><span class="comment">    /// Get the current default server response timeout value, which is used in all network requests.</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span><span class="comment">    /// The initial default setting is read from the `client_conf.ini` file or set to 1000ms if no config file was found. \sa setDefaultTimeout().</span></div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span><span class="comment"></span>    uint32_t defaultTimeout() <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span><span class="comment">    ///&lt; Set the default timeout period for server responses. The default may be inadequate on slow network links or a very busy simulator. \sa defaultTimeout()</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span><span class="comment"></span>    <span class="keywordtype">void</span> setDefaultTimeout(uint32_t ms);</div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span><span class="comment"></span> </div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span><span class="comment">    /// SimConnect is used for the network layer. This setting specifies the SimConnect.cfg index to use. The value of -1 forces a local connection.</span></div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span><span class="comment">    /// The initial default setting is read from the `client_conf.ini` file or set to `-1` if no config file was found. \sa setNetworkConfigurationId().</span></div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span><span class="comment"></span>    <span class="keywordtype">int</span> networkConfigurationId() <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span><span class="comment">    /// SimConnect is used for the network layer. This setting specifies the SimConnect.cfg index to use, or -1 to force a local connection.</span></div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span><span class="comment">    /// Note that this must be called before `connectSimulator()` invocation in order to have any effect. \sa networkConfigurationId().</span></div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span><span class="comment"></span>    <span class="keywordtype">void</span> setNetworkConfigurationId(<span class="keywordtype">int</span> configId);</div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span><span class="comment"></span> </div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span><span class="comment">    /// \name RPN calculator code execution and reusable events</span></div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span><span class="comment">    /// Run a string of MSFS _Gauge API_ calculator code in RPN format, possibly with some kind of result expected.</span></div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span><span class="comment">    /// \param code The text of the code to execute.  See https://docs.flightsimulator.com/html/Additional_Information/Reverse_Polish_Notation.htm</span></div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span><span class="comment">    /// \param resultType Expected result type, or `Enums::CalcResultType::None` (default) if no result is expected. If the type is `Enums::CalcResultType::Formatted` then the server</span></div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span><span class="comment">    ///                   runs the code using `format_calculator_string()` _Gauge API_ function (see @ bottom of RPN docs for formatting options) and the result type is always a string.</span></div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span><span class="comment">    ///                   Otherwise `execute_calculator_code()` is used and any of the result types can be returned (in fact `execute_calculator_code()` always returns any results in all 3 types at once, so even</span></div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span><span class="comment">    ///                   if a numeric result is requested, the string result will also be populated).</span></div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span><span class="comment">    /// \param pfResult A pointer to an initialized variable of `double` to store the result into if `resultType` is `Enums::CalcResultType::Double` or `Enums::CalcResultType::Integer`.</span></div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span><span class="comment">    /// \param psResult A string pointer to store the string result into. The string version is typically populated even for numeric type requests, but definitely for `Enums::CalcResultType::String` or `Enums::CalcResultType::Formatted` type requests.</span></div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span><span class="comment">    /// \return `S_OK` on success, `E_NOT_CONNECTED` if not connected to server; \n</span></div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span><span class="comment">    /// If a result is expected, may also return `E_FAIL` if the server returned Nak response, or `E_TIMEOUT` on general server communication failure.</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span><span class="comment">    /// \note _If_ a result is expected (`resultType` != `Enums::CalcResultType::None`) then this method blocks until either the Server responds or the timeout has expired (see `defaultTimeout()`).</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span><span class="comment">    /// To request calculated results in a non-blocking fashion, use a data request instead.</span></div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span><span class="comment">    ///</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span><span class="comment">    /// If you need to execute the same code multiple times, it would be more efficient to save the code as either a data request (for code returning values) or a registered event (for code not returning values).</span></div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span><span class="comment">    /// The advantage is that in those cases the calculator string is pre-compiled to byte code and saved once, then each invocation of the _Gauge API_ calculator functions uses the more efficient byte code version.</span></div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span><span class="comment">    /// (To prevent automatic data updates for data requests, just set the data request period to `Enums::UpdatePeriod::Never` or `Enums::UpdatePeriod::Once` and use the `updateDataRequest()` method to poll for value updates as needed.)</span></div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span><span class="comment">    /// See `saveDataRequest()` and `registerEvent()` respectively for details.</span></div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span><span class="comment">    /// \sa \refwce{CommandId::Exec}, defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span><span class="comment"></span>    HRESULT executeCalculatorCode(<span class="keyword">const</span> std::string &amp;code, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#ac056a41f7fdbf2fb2599ad86c3949922">WASimCommander::Enums::CalcResultType</a> resultType = <a class="code hl_enumvalue" href="namespace_w_a_sim_commander_1_1_enums.html#ac056a41f7fdbf2fb2599ad86c3949922a6adf97f83acf6453d4a6a4b1070f3754">WASimCommander::Enums::CalcResultType::None</a>, <span class="keywordtype">double</span> *pfResult = <span class="keyword">nullptr</span>, std::string *psResult = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span><span class="comment"></span> </div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span><span class="comment">    /// \name Variables accessor methods</span></div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span><span class="comment">    /// Get a Variable value by name, with optional named unit type. This is primarily useful for local (&#39;L&#39;) variables, SimVars (&#39;A&#39;) and token variables (&#39;T&#39;) which can be read via dedicated _Gauge API_ functions</span></div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span><span class="comment">    /// (`get_named_variable_value()`/`get_named_variable_typed_value()`, `aircraft_varget()`,  and `lookup_var()` respectively). \n</span></div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span><span class="comment">    /// Other variables types can also be set this way (&#39;C&#39;, &#39;E&#39;, &#39;M&#39;, etc) but such requests are simply **converted to a calculator string** and evaluated via the _Gauge API_ `execute_calculator_code()`. \n</span></div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="comment">    /// Likewise, requesting string-type variables using this method also ends up running a calculator expression on the server side. \n</span></div>
<div class="line"><a id="l00193" name="l00193"></a><span class="lineno">  193</span><span class="comment">    /// In both cases, using `WASimClient::executeCalculatorCode()` directly may be more efficient. Also, unlike `executeCalculatorCode()`, this method will not return a string representation of a numeric value.</span></div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno">  194</span><span class="comment">    /// \param variable See `VariableRequest` documentation for descriptions of the individual fields.</span></div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span><span class="comment">    /// \param pfResult Pointer to a double precision variable to hold the numeric result.</span></div>
<div class="line"><a id="l00196" name="l00196"></a><span class="lineno">  196</span><span class="comment">    /// \param psResult Pointer to a string type variable to hold a string-type result. See notes above regarding string types.</span></div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or `E_FAIL` if server returns a Nak response.</span></div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno">  198</span><span class="comment">    /// \note This method blocks until either the Server responds or the timeout has expired.</span></div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno">  199</span><span class="comment">    /// \sa \refwcc{VariableRequest}, \refwce{CommandId::Get},  defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno">  200</span><span class="comment"></span>    HRESULT getVariable(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a> &amp;variable, <span class="keywordtype">double</span> *pfResult, std::string *psResult = <span class="keyword">nullptr</span>);<span class="comment"></span></div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno">  201</span><span class="comment">    /// A convenience version of `getVariable(VariableRequest(variableName, false, unitName), pfResult)`. See `getVariable()` and `VariableRequest` for details.</span></div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span><span class="comment">    /// \param variableName Name of the local variable.</span></div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno">  203</span><span class="comment">    /// \param pfResult Pointer to a double precision variable to hold the result.</span></div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno">  204</span><span class="comment">    /// \param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic &quot;number&quot; type.</span></div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno">  205</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or `E_FAIL` if server returns a Nak response.</span></div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span><span class="comment">    /// \note This method blocks until either the Server responds or the timeout has expired. \sa \refwce{CommandId::Get},  defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno">  207</span><span class="comment"></span>    HRESULT getLocalVariable(<span class="keyword">const</span> std::string &amp;variableName, <span class="keywordtype">double</span> *pfResult, <span class="keyword">const</span> std::string &amp;unitName = std::string());<span class="comment"></span></div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno">  208</span><span class="comment">    /// Gets the value of a local variable just like `getLocalVariable()` but will also create the variable on the simulator if it doesn&#39;t already exist.</span></div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno">  209</span><span class="comment">    /// \param variableName Name of the local variable.</span></div>
<div class="line"><a id="l00210" name="l00210"></a><span class="lineno">  210</span><span class="comment">    /// \param pfResult Pointer to a double precision variable to hold the result.</span></div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span><span class="comment">    /// \param defaultValue The L var will be created on the simulator if it doesn&#39;t exist yet using this initial value (and this same value will be returned in `pfResult`).</span></div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span><span class="comment">    /// \param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic &quot;number&quot; type.</span></div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno">  213</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or `E_FAIL` if server returns a Nak response.</span></div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span><span class="comment">    /// \note This method blocks until either the Server responds or the timeout has expired. \sa \refwce{CommandId::GetCreate}, defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span><span class="comment"></span>    HRESULT getOrCreateLocalVariable(<span class="keyword">const</span> std::string &amp;variableName, <span class="keywordtype">double</span> *pfResult, <span class="keywordtype">double</span> defaultValue = 0.0, <span class="keyword">const</span> std::string &amp;unitName = std::string());</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span><span class="comment"></span> </div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span><span class="comment">    /// Set a Variable value by name, with optional named unit type. Although any settable variable type can set this way, it is primarily useful for local (`L`)</span></div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span><span class="comment">    /// variables which can be set via dedicated _Gauge API_ functions (`set_named_variable_value()` and `set_named_variable_typed_value()`). \n\n</span></div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span><span class="comment">    /// Other variables types can also be set this way but such requests are simply converted to a calculator string and</span></div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span><span class="comment">    /// evaluated via the _Gauge API_ `execute_calculator_code()`. Using `WASimClient::executeCalculatorCode()` directly may be more efficient. \n</span></div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span><span class="comment">    /// The following conditions must be observed:</span></div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span><span class="comment">    /// - The variable type in `VariableRequest::variableType` must be &quot;settable&quot; (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;H&#39;, &#39;K&#39;, &#39;L&#39;, or &#39;Z&#39;), otherwise an `E_INVALIDARG` result is returned.</span></div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span><span class="comment">    /// - Setting an &#39;A&#39; type variable this way _requires_ the actual variable name in `VariableRequest::variableName` -- using just an ID returns `E_INVALIDARG`. \n</span></div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span><span class="comment">    ///   (Other settable variable types don&#39;t have any associated ID anyway, so this is not an issue.)</span></div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span><span class="comment">    /// - For any variable type _other than_ &#39;L&#39;, a Unit can only be specified as a string (in `VariableRequest::unitName`), not an ID.</span></div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span><span class="comment">    ///   Using only an ID will not cause an error, but the unit will not be included in the generated RPN code. \n</span></div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span><span class="comment">    ///   For &#39;L&#39; variable types, if both a name and ID are provided, the numeric ID is used insted of the name (this avoids a lookup on the server side).</span></div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span><span class="comment">    ///</span></div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span><span class="comment">    /// \param variable See `VariableRequest` documentation for descriptions of the individual fields.</span></div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span><span class="comment">    /// \param value The numeric value to set.</span></div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, or `E_FAIL` on general failure (unlikely).</span></div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span><span class="comment">    /// \sa \refwce{CommandId::Set}</span></div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span><span class="comment"></span>    HRESULT setVariable(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a> &amp;variable, <span class="keyword">const</span> <span class="keywordtype">double</span> value);<span class="comment"></span></div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span><span class="comment">    /// This is an overloaded method. This version allows setting an &#39;A&#39; type (SimVar) variable to a string value. **Only &#39;A&#39; type variables can be set this way.** \n</span></div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span><span class="comment">    /// Since there is actually no direct way to set string-type values from WASM code, this is just a convenience method and simply invokes SimConnect to do the work.</span></div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span><span class="comment">    /// On first use with a new variable name it will set up a mapping of the name to an internally-assigned ID (calling `SimConnect_AddToDataDefinition()`) and cache that mapping.</span></div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span><span class="comment">    /// Then on subsequent invocations on the same variable the mapped ID will be used directly. The mappings are invalidated when disconnecting from the simulator.</span></div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span><span class="comment"></span>    HRESULT setVariable(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a> &amp;variable, <span class="keyword">const</span> std::string &amp;stringValue);</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span><span class="comment"></span> </div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span><span class="comment">    /// A convenience version of `setVariable()` for Local variable types. Equivalent to `setVariable(VariableRequest(variableName, false, unitName), value)`. See `setVariable()` and `VariableRequest` for details.</span></div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span><span class="comment">    /// \param variableName Name of the local variable.</span></div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span><span class="comment">    /// \param value The value to set.</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span><span class="comment">    /// \param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic &quot;number&quot; type.</span></div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, or `E_FAIL` on general failure (unlikely).</span></div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span><span class="comment">    /// \sa \refwce{CommandId::Set}</span></div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="comment"></span>    HRESULT setLocalVariable(<span class="keyword">const</span> std::string &amp;variableName, <span class="keyword">const</span> <span class="keywordtype">double</span> value, <span class="keyword">const</span> std::string &amp;unitName = std::string());<span class="comment"></span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno">  247</span><span class="comment">    /// Set a Local Variable value by variable name, creating it first if it does not already exist. This first calls the `register_named_variable()` _Gauge API_ function to get the ID from the name,</span></div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span><span class="comment">    /// which creates the variable if it doesn&#39;t exist. The returned ID (new or existing) is then used to set the value. Use the `lookup()` method to check for the existence of a variable name.</span></div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span><span class="comment">    /// Equivalent to `setVariable(VariableRequest(variableName, true, unitName), value)`. See `setVariable()` and `VariableRequest` for details.</span></div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span><span class="comment">    /// \param variableName Name of the local variable.</span></div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span><span class="comment">    /// \param value The value to set. Becomes the initial value if the variable is created.</span></div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span><span class="comment">    /// \param unitName Optional unit specifier to use. Most Local vars do not specify a unit and default to a generic &quot;number&quot; type.</span></div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` on parameter validation errors, `E_NOT_CONNECTED` if not connected to server, or `E_FAIL` on general failure (unlikely).</span></div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span><span class="comment">    /// \sa \refwce{CommandId::SetCreate}</span></div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span><span class="comment"></span>    HRESULT setOrCreateLocalVariable(<span class="keyword">const</span> std::string &amp;variableName, <span class="keyword">const</span> <span class="keywordtype">double</span> value, <span class="keyword">const</span> std::string &amp;unitName = std::string());</div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span><span class="comment"></span> </div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span><span class="comment">    /// Sets a numeric value on an &#39;A&#39; (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable. \n</span></div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span><span class="comment">    /// This is a convenience version of `setVariable()`, equivalent to `setVariable(VariableRequest(variableName, unitName), value)`. See `setVariable()` and `VariableRequest` for details.\n</span></div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span><span class="comment">    /// Note that `variableName` can optionally contain an index after a colon (eg. `VAR NAME:1`), or the `setSimVarVariable(const string&amp; name, uint8_t index, const string&amp; unit, double value)`</span></div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span><span class="comment">    /// overload could be used to provide the index separately. For MSFS 2024 Sim Vars which use component name suffixes, specify them in the variable name itself.</span></div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a5f0f7e3575c605a44516a407251567fe">  262</a></span><span class="comment"></span>    <span class="keyword">inline</span> HRESULT <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a5f0f7e3575c605a44516a407251567fe">setSimVarVariable</a>(<span class="keyword">const</span> std::string &amp;variableName, <span class="keyword">const</span> std::string &amp;unitName, <span class="keywordtype">double</span> value) { <span class="keywordflow">return</span> setVariable(<a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a>(variableName, unitName), value); }<span class="comment"></span></div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span><span class="comment">    /// Sets a numeric value on an indexed &#39;A&#39; (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable. \n</span></div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="comment">    /// This is a convenience version of `setVariable()`, equivalent to `setVariable(VariableRequest(variableName, unitName, index), value)`. See `setVariable()` and `VariableRequest` for details.</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno">  265</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ace0a22e5f77b43adf67e1b4642a1ed5c">  266</a></span><span class="comment"></span>    <span class="keyword">inline</span> HRESULT <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ace0a22e5f77b43adf67e1b4642a1ed5c">setSimVarVariable</a>(<span class="keyword">const</span> std::string &amp;variableName, uint8_t index, <span class="keyword">const</span> std::string &amp;unitName, <span class="keywordtype">double</span> value) { <span class="keywordflow">return</span> setVariable(<a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a>(variableName, unitName, index), value); }<span class="comment"></span></div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span><span class="comment">    /// Sets a string value on an &#39;A&#39; (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable. \n</span></div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span><span class="comment">    /// This is a convenience version of `setVariable()`, equivalent to `setVariable(VariableRequest(`&#39;A&#39;`, variableName), stringValue)`. See `setVariable(const VariableRequest &amp;, const std::string &amp;)` for details.</span></div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a79b80707c04ebfd07c42b46abc753dfc">  270</a></span><span class="comment"></span>    <span class="keyword">inline</span> HRESULT <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a79b80707c04ebfd07c42b46abc753dfc">setSimVarVariable</a>(<span class="keyword">const</span> std::string &amp;variableName, <span class="keyword">const</span> std::string &amp;stringValue) { <span class="keywordflow">return</span> setVariable(<a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a>(<span class="charliteral">&#39;A&#39;</span>, variableName), stringValue); }<span class="comment"></span></div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span><span class="comment">    /// Sets a string value on an indexed &#39;A&#39; (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable. \n</span></div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span><span class="comment">    /// This is a convenience version of `setVariable()`, equivalent to `setVariable(VariableRequest(variableName, {}, index), stringValue)`. See `setVariable(const VariableRequest &amp;, const std::string &amp;)` for details.</span></div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ae3e6289323d9d13cbf928e0bbf521595">  274</a></span><span class="comment"></span>    <span class="keyword">inline</span> HRESULT <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ae3e6289323d9d13cbf928e0bbf521595">setSimVarVariable</a>(<span class="keyword">const</span> std::string &amp;variableName, uint8_t index, <span class="keyword">const</span> std::string &amp;stringValue) { <span class="keywordflow">return</span> setVariable(<a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">VariableRequest</a>(variableName, {}, index), stringValue); }</div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span><span class="comment"></span> </div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span><span class="comment">    /// \name Data change subscriptions (variables and calculated results)</span></div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span><span class="comment">    /// Add a new `WASimCommander::DataRequest` for a variable or calculated result, or update an existing data request with the same `DataRequest::requestId`.</span></div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span><span class="comment">    /// Data changes (updates) are delivered asynchronously via the callback function set with `setDataCallback()`, which then passes a `DataRequestRecord` structure as the callback argument</span></div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span><span class="comment">    /// (this provides both a reference to the original `DataRequest` registered here, as well as result data).</span></div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span><span class="comment">    /// \param request The `WASimCommander::DataRequest` structure to process. See `WASimCommander::DataRequest` documentation for details of the structure members.</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno">  284</span><span class="comment">    /// \param async Set to `false` (default) to wait for an `Ack`/`Nak` response from the server before returning from this method, or `true` to return without waiting for a response. See return values and the Note below for more details.</span></div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if there is a problem with the `DataRequest` contents. \n</span></div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span><span class="comment">    /// If currently connected to the server and `async` is `false`, may also return `E_FAIL` if the server returned `Nak` response, or `E_TIMEOUT` on general server communication failure.</span></div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span><span class="comment">    /// \note If currently connected to the server and the `async` param is `false`, this method will block until either the Server responds or the timeout has expired (see `defaultTimeout()`).</span></div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span><span class="comment">    /// If the client is _not_ currently connected to the server, the request is queued until the next connection is established (and this method is non-blocking regardless of `async` argument).</span></div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span><span class="comment">    /// \par Tracking async calls</span></div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span><span class="comment">    /// To track the status of an async request, set a callback function with `setCommandResultCallback()`. The server should respond with an \refwce{CommandId::Ack} or \refwce{CommandId::Nak}</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span><span class="comment">    /// \refwc{Command} where the `uData` value is \refwce{CommandId::Subscribe} and the \refwc{Command::token} will be the `requestId` value from the given `request` struct.</span></div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span><span class="comment">    /// \sa  \refwc{DataRequest} \refwce{CommandId::Subscribe}, removeDataRequest(), updateDataRequest(), setDataCallback(), DataRequestRecord</span></div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span><span class="comment"></span>    HRESULT saveDataRequest(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_data_request.html">DataRequest</a> &amp;request, <span class="keywordtype">bool</span> async = <span class="keyword">false</span>);<span class="comment"></span></div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span><span class="comment">    /// Remove a previously-added `DataRequest`. This clears the subscription and any tracking/meta data from both server and client sides.</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span><span class="comment">    /// Using this method is effectively the same as calling `dataRequest()` with a `DataRequest` of type `RequestType::None`.</span></div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span><span class="comment">    /// \param requestId ID of the request to remove.</span></div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span><span class="comment">    /// \return `S_OK` on success, `E_FAIL` if the original request wasn&#39;t found.</span></div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span><span class="comment">    /// \note If the subscription data may be needed again in the future, it would be more efficient to edit the request (using `saveDataRequest()`) and suspend updates by setting the `DataRequest::period` to `UpdatePeriod::Never`.</span></div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span><span class="comment">    /// To resume updates change the period again.</span></div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span><span class="comment">    /// \sa \refwc{DataRequest}, \refwce{CommandId::Subscribe}, saveDataRequest(), updateDataRequest()</span></div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span><span class="comment"></span>    HRESULT removeDataRequest(<span class="keyword">const</span> uint32_t requestId);<span class="comment"></span></div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span><span class="comment">    /// Trigger a data update on a previously-added `DataRequest`. Designed to refresh data on subscriptions with update periods of `UpdatePeriod::Never` or `UpdatePeriod::Once`, though it can be used with any subscription.</span></div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span><span class="comment">    /// Using this update method also skips any equality checks on the server side (though any delta epsilon value remains in effect on client side).</span></div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span><span class="comment">    /// \param requestId The ID of a previously added `DataRequest`.</span></div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span><span class="comment">    /// \return `S_OK` on success, `E_FAIL` if the original request wasn&#39;t found,.</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span><span class="comment">    /// \sa \refwce{CommandId::Update}, saveDataRequest(), removeDataRequest()</span></div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span><span class="comment"></span>    HRESULT updateDataRequest(uint32_t requestId);</div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span><span class="comment"></span> </div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span><span class="comment">    /// Returns a copy of a `DataRequestRecord` which has been previously added. If the request with the given `requestId` doesn&#39;t exist, an invalid `DataRequestRecord` is returned which has</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span><span class="comment">    /// the members `DataRequest::requestId` set to `-1`, `DataRequest::valueSize` set to `0`, and `DataRequest::requestType` set to `RequestType::None`.</span></div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span><span class="comment"></span>    <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_data_request_record.html">DataRequestRecord</a> dataRequest(uint32_t requestId) <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span><span class="comment">    /// Returns a list of all data requests which have been added to the Client so far. (These are returned by copy operation, so for a long list it may get &quot;expensive.&quot;)</span></div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span><span class="comment"></span>    std::vector&lt;DataRequestRecord&gt; dataRequests() <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span><span class="comment">    /// Returns a list of all `DataRequest::requestId`s which have been added to the Client so far.</span></div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span><span class="comment"></span>    std::vector&lt;uint32_t&gt; dataRequestIdsList() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span><span class="comment"></span> </div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span><span class="comment">    /// Enables or disables all data request subscription updates at the same time. Use this to temporarily suspend value update checks when they are not needed, but may be again in the future.</span></div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span><span class="comment">    /// This is a lot more efficient than disconnecting and re-connecting to the server, since all the data requests need to be re-created upon every new connection (similar to SimConnect itself).</span></div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span><span class="comment">    /// \since{v1.2}</span></div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span><span class="comment">    /// This method can be called while not connected to the server. In this case the setting is saved and sent to the server upon next connection, before sending any data request subscriptions.</span></div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span><span class="comment">    /// This way updates could be suspended upon initial connection, then re-enabled when the data is actually needed.</span></div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno">  322</span><span class="comment">    /// \return `S_OK` on success; If currently connected to the server, may also return `E_TIMEOUT` on general server communication failure.</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span><span class="comment"></span>    HRESULT setDataRequestsPaused(<span class="keywordtype">bool</span> paused) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span><span class="comment"></span> </div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span><span class="comment">    /// \name RPN calculator code execution and reusable events</span></div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span><span class="comment">    /// Register a reusable event which executes a pre-set RPN calculator code string. The code is pre-compiled and stored on the server for quicker execution.</span></div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span><span class="comment">    /// The event can have an optional custom name for direct use with any SimConnect client. Registered events can also be triggered by using the `transmitEvent()` method.</span></div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span><span class="comment">    /// If the server is not currently connected, the event registration will be queued and sent next time a connection is established.</span></div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno">  332</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if the resulting code string is too long or if trying to change the name of an already registered event.</span></div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span><span class="comment">    /// \sa RegisteredEvent, \refwce{CommandId::Register}, removeEvent(), transmitEvent()</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span><span class="comment"></span>    HRESULT registerEvent(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_registered_event.html">RegisteredEvent</a> &amp;eventData);<span class="comment"></span></div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span><span class="comment">    /// Remove an event previously registered with `registerEvent()` method. This is effectively the same as calling `registerEvent()` with an empty `code` parameter.</span></div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span><span class="comment">    /// If the server is not currently connected, the removal request will be queued and sent next time a connection is established.</span></div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span><span class="comment">    /// \param eventId ID of the previously registered event.</span></div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if the eventId wasn&#39;t found.</span></div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span><span class="comment">    /// \sa \refwce{CommandId::Register}, registerEvent(), transmitEvent()</span></div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span><span class="comment"></span>    HRESULT removeEvent(uint32_t eventId);<span class="comment"></span></div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span><span class="comment">    /// Trigger an event previously registered with `registerEvent()`. This is a more direct alternative to triggering events by name via SimConnect.</span></div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno">  342</span><span class="comment">    /// \param eventId ID of the previously registered event. If the event hasn&#39;t been registered, the server will log a warning but otherwise nothing will happen.</span></div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span><span class="comment">    /// \return `S_OK` on success, `E_FAIL` on general failure (unlikely), `E_NOT_CONNECTED` if not connected to server.</span></div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span><span class="comment">    /// \sa \refwce{CommandId::Transmit}, registerEvent(), removeEvent()</span></div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span><span class="comment"></span>    HRESULT transmitEvent(uint32_t eventId);</div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span><span class="comment"></span> </div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span><span class="comment">    /// Returns a copy of a `RegisteredEvent` which has been previously added with `registerEvent()`. If the event with the given `eventId` doesn&#39;t exist, an invalid `RegisteredEvent` is returned which has</span></div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span><span class="comment">    /// the members `RegisteredEvent::eventId` set to `-1`, and `RegisteredEvent::code` and `RegisteredEvent::name` both empty.</span></div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span><span class="comment"></span>    <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_registered_event.html">RegisteredEvent</a> registeredEvent(uint32_t eventId);<span class="comment"></span></div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span><span class="comment">    /// Returns a list of all registered events which have been added to the Client with `registerEvent()`. The list members are created by copy.</span></div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span><span class="comment"></span>    std::vector&lt;RegisteredEvent&gt; registeredEvents() <span class="keyword">const</span>;</div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span><span class="comment"></span> </div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span><span class="comment">    /// \name Simulator Key Events</span></div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span><span class="comment">    /// Can be used to trigger standard Simulator &quot;Key Events&quot; as well as &quot;custom&quot; _Gauge API/SimConnect_ events. Up to 5 optional values can be passed onto the event handler.</span></div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno">  358</span><span class="comment">    /// This provides functionality similar to the _Gauge API_ function `trigger_key_event_EX1()` and `SimConnect_TransmitClientEvent[_EX1()]`.  \n\n</span></div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span><span class="comment">    /// *Standard* Key Event IDs can be found in the SimConnect SDK header file &#39;MSFS/Legacy/gauges.h&#39; in the form of `KEY_*` macro values, and event names can also be</span></div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span><span class="comment">    /// resolved to IDs programmatically using the `lookup()` method. No preliminary setup is required to trigger these events, but a full connection to WASimModule (&quot;server&quot;) is needed.</span></div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span><span class="comment">    /// These are triggered on the simulator side using `trigger_key_event_EX1()` function calls. \n\n</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="comment">    /// *Custom Events* for which a numeric ID is already known (typically in the _Gauge API_ `THIRD_PARTY_EVENT_ID_MIN`/`THIRD_PARTY_EVENT_ID_MAX` ID range)</span></div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span><span class="comment">    /// can also be triggered directly as with standard events. These types of events are also passed directly to `trigger_key_event_EX1()`. \n\n</span></div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span><span class="comment">    /// *Named Custom Events*, for which an ID is not known or predefined, **must** first be registered with `registerCustomKeyEvent()`, which creates and maps (and optionally returns)</span></div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span><span class="comment">    /// a unique ID corresponding to the custom event name. An active simulator (SimConnect) connection is required to trigger these types of events.</span></div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span><span class="comment">    /// They are invoked via `SimConnect_TransmitClientEvent[_EX1()]` method directly from this client (this is actually just a convenience for the WASimClient user to avoid needing a separate SimConnect session).</span></div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span><span class="comment">    /// Which actual SimConnect function is used depends on how the custom event was registered (default is to use the newer &quot;_EX1&quot; version which allows up to 5 event values). \n</span></div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span><span class="comment">    /// See docs for `registerCustomKeyEvent()` for further details on using custom simulator events.</span></div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span><span class="comment">    /// \param keyEventId Numeric ID of the Event to trigger.</span></div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span><span class="comment">    /// \param v1,v2,v3,v4,v5 Optional values to pass to the event handler. Defaults are all zeros.</span></div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span><span class="comment">    /// \return `S_OK` on success, `E_NOT_CONNECTED` if not connected (server or sim, see above), `E_TIMEOUT` on server communication failure, or `E_FAIL` on unexpected SimConnect error.</span></div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span><span class="comment">    /// \note For Key Events triggered via `trigger_key_event_EX1()`, Server responds asynchronously with an Ack/Nak response to \refwce{CommandId::SendKey} command type;</span></div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span><span class="comment">    ///   A &#39;Nak&#39; means the event ID is clearly not valid (eg. zero), but otherwise the simulator provides no feedback about event execution</span></div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span><span class="comment">    ///   (from [their docs](https://docs.flightsimulator.com/html/Programming_Tools/WASM/Gauge_API/trigger_key_event_EX1.htm#return_values): &quot;If the event requested is not appropriate, it will simply not happen.&quot;). \n\n</span></div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno">  375</span><span class="comment">    ///   For _custom named_ events, triggered via `SimConnect_TransmitClientEvent[_EX1()]`, SimConnect may asynchronously send EXCEPTION type response messages if the ID isn&#39;t valid</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="comment">    ///   (likely because the event hasn&#39;t been successfully registered with `registerCustomKeyEvent()`). These messages are passed through to WASimClient&#39;s logging facilities at the `Warning` level.</span></div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span><span class="comment">    ///   But again there is no actual confirmation that the event is going to do anything.</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span><span class="comment">    /// \since v1.3.0 - Added ability to trigger custom named events.</span></div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span><span class="comment"></span>    HRESULT sendKeyEvent(uint32_t keyEventId, uint32_t v1 = 0, uint32_t v2 = 0, uint32_t v3 = 0, uint32_t v4 = 0, uint32_t v5 = 0) <span class="keyword">const</span>;</div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span><span class="comment"></span> </div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span><span class="comment">    /// This is an overloaded method. See `sendKeyEvent(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) const` for main details.</span></div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span><span class="comment">    /// This version allows triggering Key Events by name instead of an ID. \n\n</span></div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span><span class="comment">    /// All simulator event names must be resolved, or mapped, to a numeric ID before they can be triggered (used).</span></div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span><span class="comment">    /// The first time this method is invoked with a particular event name, it tries to associate that name with an ID (based on the event name, as described below).</span></div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span><span class="comment">    /// If successful, the ID is cached, so subsequent calls to this method, with the same event name, will use the cached ID instead of trying to resolve the name again.</span></div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span><span class="comment">    /// - For _standard_ Key Events, the name is resolved to an ID using the &#39;lookup()&#39; method and the resulting ID (if valid) is cached for future uses. There **must** be an active server connection for this to work.</span></div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span><span class="comment">    /// - For _custom_ events (names that contain a &quot;.&quot; (period) or start with a &quot;#&quot;), the event is first registered using `registerCustomKeyEvent()` and the resulting ID is cached if that succeeds.</span></div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span><span class="comment">    ///</span></div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span><span class="comment">    /// \param keyEventName Name of the Event to trigger.</span></div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span><span class="comment">    /// \param v1,v2,v3,v4,v5 Optional values to pass to the event handler. Defaults are all zeros.</span></div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if event name could not be resolved to an ID, `E_NOT_CONNECTED` if not connected (server or sim, depending on event type),</span></div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span><span class="comment">    /// `E_TIMEOUT` on server communication failure, or `E_FAIL` on unexpected SimConnect error.</span></div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno">  393</span><span class="comment">    /// \note The name-to-ID cache is kept as a simple `std::unordered_map` type, so if you have a better way to save the event IDs from `lookup()` or `registerCustomKeyEvent()`,</span></div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span><span class="comment">    /// use that instead, and call the more efficient `sendKeyEvent(eventId, ...)` overload directly.</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="comment">    /// \since v1.3.0 - Added ability to trigger custom named events.</span></div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span><span class="comment"></span>    HRESULT sendKeyEvent(<span class="keyword">const</span> std::string &amp;keyEventName, uint32_t v1 = 0, uint32_t v2 = 0, uint32_t v3 = 0, uint32_t v4 = 0, uint32_t v5 = 0);</div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span><span class="comment"></span> </div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span><span class="comment">    /// Register a &quot;Custom Simulator [Key] Event&quot; by providing an event name. The method optionally returns the generated event ID, which can later be used with `sendKeyEvent()` method instead of the event name.</span></div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span><span class="comment">    /// It can also be used to look up a previous registration&#39;s ID if the event name has already been registered. \n\n</span></div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span><span class="comment">    /// Custom event names are mapped to internally-generated unique IDs using a standard SimConnect call to</span></div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span><span class="comment">    /// [MapClientEventToSimEvent](https://docs.flightsimulator.com/html/Programming_Tools/SimConnect/API_Reference/Events_And_Data/SimConnect_MapClientEventToSimEvent.htm#parameters),</span></div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span><span class="comment">    /// and the documentation briefly describes custom event usage and name syntax in the `EventName` parameter description. This method serves a similar purpose (and in fact eventually calls that same SimConnect function). \n\n</span></div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span><span class="comment">    /// The mappings must be re-established every time a new connection with SimConnect is made, which WASimClient takes care of automatically. If currently connected to the simulator, the event is immediately mapped,</span></div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno">  404</span><span class="comment">    /// otherwise it will be mapped upon the next connection. An event registration can be removed with `removeCustomKeyEvent()` which will prevent any SimConnect mapping from being created upon the _next_ connection. \n\n</span></div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span><span class="comment">    /// If you&#39;re not going to store the ID that will be generated anyway, `sendKeyEvent(customEventName, ...)` can be used directly, which will automatically call this method the first time the event name is used.</span></div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="comment">    /// The ID can always be looked up later if needed (by calling this method). \n\n</span></div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span><span class="comment">    /// Note that the custom event mapping/triggering feature is actually just a convenience for the WASimClient user and doesn&#39;t involve the usual server interactions (WASimModule) at all.</span></div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span><span class="comment">    /// \param customEventName Name of the Event to register. The event name _must_ contain a &quot;.&quot; (period) or start with a &quot;#&quot;, otherwise an `E_INVALIDARG` result is returned. \n</span></div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span><span class="comment">    ///   If an event with the same name has already been registered, the method returns `S_OK` and no further actions are performed (besides setting the optional `puiCustomEventId` pointer value, see below).</span></div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span><span class="comment">    /// \param puiCustomEventId Optional pointer to 32-bit unsigned integer variable to return the generated event ID. This ID can be used to trigger the event later using `sendKeyEvent()` (which is more efficient than using the event name each time).</span></div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span><span class="comment">    ///   The ID will always be unique per given event name, and is always equal to or greater than the `Client::CUSTOM_KEY_EVENT_ID_MIN` constant value. \n</span></div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span><span class="comment">    ///   The pointer&#39;s value will be populated even if the event name was already registered (with the result of the previously generated ID).</span></div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span><span class="comment">    /// \param useLegacyTransmit Optional, default `false`. Boolean value indicating that the deprecated `SimConnect_TransmitClientEvent()` function should be used to trigger the event instead of the newer `SimConnect_TransmitClientEvent_EX1()`.</span></div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span><span class="comment">    ///   This may be necessary to support models which haven&#39;t updated to the newer version of the event handler. Note that the old `TransmitClientEvent()` function only supports sending 1 event value (vs. 5 for the &quot;_EX1&quot; version). \n</span></div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span><span class="comment">    ///   To re-register the same event name but with a different value for `useLegacyTransmit` parameter, first remove the initial registration with `removeCustomKeyEvent()` and then call this method again.</span></div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if the event name is invalid.</span></div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span><span class="comment"></span>    HRESULT registerCustomKeyEvent(<span class="keyword">const</span> std::string &amp;customEventName, uint32_t *puiCustomEventId = <span class="keyword">nullptr</span>, <span class="keywordtype">bool</span> useLegacyTransmit = <span class="keyword">false</span>);<span class="comment"></span></div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span><span class="comment">    /// Remove a Custom Event previously registered with `registerCustomEvent()` method using the event&#39;s name.</span></div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span><span class="comment">    /// This will prevent the custom event from being mapped _next_ time the client connects to SimConnect.</span></div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span><span class="comment">    /// \note SimConnect provides no way to remove a registered Custom event. Any active SimConnect mapping will remain in effect until SimConnect is disconnected (and can still be invoked with the corresponding ID, but not by name).</span></div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span><span class="comment">    /// \param customEventName full name of the previously registered event. Must be the same name as used with `registerCustomKeyEvent()`.</span></div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if the eventId wasn&#39;t found.</span></div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span><span class="comment"></span>    HRESULT removeCustomKeyEvent(<span class="keyword">const</span> std::string &amp;customEventName);<span class="comment"></span></div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span><span class="comment">    /// This is an overloaded method. Same as `removeCustomKeyEvent(const string &amp;)` but the event can be specified using the associated numeric event ID (originally returned from `registerCustomKeyEvent()`) instead of the name.</span></div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span><span class="comment">    /// \param eventId ID of the previously registered event.</span></div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span><span class="comment">    /// \return `S_OK` on success, `E_INVALIDARG` if the eventId wasn&#39;t found.</span></div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span><span class="comment">    /// \since v1.3.0</span></div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span><span class="comment"></span>    HRESULT removeCustomKeyEvent(uint32_t eventId);</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span><span class="comment"></span> </div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno">  433</span><span class="comment">    /// \name Metadata retrieval</span></div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span><span class="comment">    /// Send a request for a list update to the server. The results are delivered using the callback set in `setListResultsCallback()`.</span></div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span><span class="comment">    /// \param itemsType The type of thing to list. Supported types are local variables (`Enums::LookupItemType::LocalVariable`, default), subscribed Data Requests (`Enums::LookupItemType::DataRequest`), and Registered Events (`Enums::LookupItemType::RegisteredEvent`).</span></div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span><span class="comment">    /// \return  `S_OK` on success, `E_INVALIDARG` if the item type is not supported, `E_NOT_CONNECTED` if not connected to server.</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span><span class="comment">    /// \note The list result callback is invoked from a new thread which delivers the results (\refwcc{ListResult} structure). Also check the `ListResult::result` HRESULT return code to be sure the list command completed successfully</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span><span class="comment">    /// (which may be `S_OK`, `E_FAIL` if server returned `Nak`, or `E_TIMEOUT` if the list request did not complete (results may be empty or partial)).</span></div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span><span class="comment">    /// \sa \refwce{CommandId::List}</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span><span class="comment"></span>    HRESULT list(<a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#ab1b85706615bc0e57fa6d8d464bf8a3d">WASimCommander::Enums::LookupItemType</a> itemsType = <a class="code hl_enumvalue" href="namespace_w_a_sim_commander_1_1_enums.html#ab1b85706615bc0e57fa6d8d464bf8a3da89179ec269c2cab46e905f38ae8978cb">WASimCommander::Enums::LookupItemType::LocalVariable</a>);</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span><span class="comment"></span> </div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span><span class="comment">    /// Request a lookup of a named item to find its corresponding numeric ID. \n</span></div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span><span class="comment">    /// Most lookup types are done on the server side, so an active connection is required. The exception is looking up Key Event IDs (\refwce{LookupItemType::KeyEventId}), which are performed locally.</span></div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span><span class="comment">    /// \param itemType The type of item to look up. A type of variable or a measurement unit. See the \refwce{LookupItemType} documentation for details.</span></div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span><span class="comment">    /// \param itemName The name of the thing to check for.</span></div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span><span class="comment">    /// \param piResult Pointer to 32-bit signed integer variable to hold the result.</span></div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span><span class="comment">    /// \return `S_OK` on success, `E_FAIL` if server returns a Nak response (typically means the item name wasn&#39;t found), `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure.</span></div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span><span class="comment">    /// \note Except for Key Event ID type lookups, this method blocks until either the Server responds or the timeout has expired. \sa defaultTimeout(), setDefaultTimeout()</span></div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span><span class="comment"></span>    HRESULT lookup(<a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#ab1b85706615bc0e57fa6d8d464bf8a3d">WASimCommander::Enums::LookupItemType</a> itemType, <span class="keyword">const</span> std::string &amp;itemName, int32_t *piResult);</div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span><span class="comment"></span> </div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span><span class="comment">    /// \name Low level API</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span><span class="comment">    /// Sends a command, in the form of a `WASimCommander::Command` structure, to the server for processing. The various command types and the data requirements for each are described in the `WASimCommander::Enums::CommandId` documentation.</span></div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span><span class="comment">    /// To receive command responses from the server, set a callback with `setCommandResultCallback()`, then check the results for a `Command::token` which matches the `token` set in the command you&#39;re sending here.</span></div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span><span class="comment">    /// \return `S_OK` on success, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure.</span></div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span><span class="comment"></span>    HRESULT sendCommand(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;command) <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span><span class="comment">    /// Sends a command, in the form of a `WASimCommander::Command` structure, to the server for processing and waits for a reply (an `Ack/Nak` response `Command`).</span></div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span><span class="comment">    /// The various command types and the data requirements for each are described in the `WASimCommander::Enums::CommandId` documentation.</span></div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span><span class="comment">    /// \param command The `Command` struct defining the command and associated data to send.</span></div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span><span class="comment">    /// \param response Pointer to an initialised `Command` structure for storing the resulting response (a Command with a `commandId` of `Ack` or `Nak`), if any.</span></div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span><span class="comment">    /// \param timeout The maximum time to wait for a response, in milliseconds. If `0` (default) then the default network timeout value is used (`defaultTimeout()`, `setDefaultTimeout()`).</span></div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span><span class="comment">    /// \return `S_OK` on success, `E_NOT_CONNECTED` if not connected to server, `E_TIMEOUT` on server communication failure, or possibly `E_FAIL` on unknown error (check log for details).</span></div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span><span class="comment"></span>    HRESULT sendCommandWithResponse(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;command, <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> *response, uint32_t timeout = 0);</div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span><span class="comment"></span> </div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span><span class="comment">    /// \name  Logging settings</span></div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span><span class="comment">    /// Get the current minimum logging severity level for the specified `facility` and `source`.  \sa setLogLevel(), setLogCallback(), \refwce{CommandId::Log}</span></div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span><span class="comment">    /// \param facility **One** of `WASimCommander::LogFacility` enum flag values. This must be only one of the available flags, not a combination.  The `Remote` facility is the one delivered via the log callback handler.</span></div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span><span class="comment">    /// \param source One of \refwcc{LogSource} enum values.</span></div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span><span class="comment">    /// \return The current `WASimCommander::LogLevel` value, or `LogLevel::None` if the parameters were ivalid or the actual level is unknown (see Note below).</span></div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span><span class="comment">    /// \note The remote server logging level for `File` and `Console` facilities is unknown at Client startup. The returned values are only going to be correct if they were set by this instance of the Client (using `setLogLevel()`).</span></div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span><span class="comment"></span>    <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#a7311e9d8f917bbcbb202497114e5f2c5">WASimCommander::Enums::LogLevel</a> logLevel(<a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#af3131943610c59d71d8b69dd7b2cab97">WASimCommander::Enums::LogFacility</a> facility, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051">LogSource</a> source = <a class="code hl_enumvalue" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051a577d7068826de925ea2aec01dbadf5e4">LogSource::Client</a>) <span class="keyword">const</span>;<span class="comment"></span></div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span><span class="comment">    /// Set the current minimum logging severity level for the specified `facility` and `source` to `level`. \sa logLevel(), setLogCallback(), \refwce{CommandId::Log}</span></div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span><span class="comment">    /// \param level The new minimum level. One of `WASimCommander::LogLevel` enum values. Use `LogLevel::None` to disable logging on the given facility/source.</span></div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span><span class="comment">    /// \param facility One or more of `WASimCommander::LogFacility` enum flags. The `LogFacility::Remote` facility is the one delivered via the log callback handler.</span></div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span><span class="comment">    /// \param source One of \refwcc{LogSource} enum values.</span></div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span><span class="comment"></span>    <span class="keywordtype">void</span> setLogLevel(<a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#a7311e9d8f917bbcbb202497114e5f2c5">WASimCommander::Enums::LogLevel</a> level, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_enums.html#af3131943610c59d71d8b69dd7b2cab97">WASimCommander::Enums::LogFacility</a> facility = <a class="code hl_enumvalue" href="namespace_w_a_sim_commander_1_1_enums.html#af3131943610c59d71d8b69dd7b2cab97af8508f576cd3f742dfc268258dcdf0dd">WASimCommander::Enums::LogFacility::Remote</a>, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051">LogSource</a> source = <a class="code hl_enumvalue" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051a577d7068826de925ea2aec01dbadf5e4">LogSource::Client</a>);</div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span><span class="comment"></span> </div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span><span class="comment">    /// \name Callbacks</span></div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span><span class="comment">    /// \note In general, callbacks _may_ be invoked concurrently (and possibly from different threads).</span></div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span><span class="comment">    /// The callback handler functions should at least be reentrant (if not thread-safe) since they could be called at any time.</span></div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span><span class="comment">    /// Check the individual method documentation for more details about possible concurrency and threading. \n</span></div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span><span class="comment">    /// The client can be built with \ref WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS macro/definition set to `0` to disable concurrency.</span></div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span><span class="comment">    ///</span></div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span><span class="comment">    /// &lt;hr&gt;</span></div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span><span class="comment">    /// \{</span></div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span><span class="comment"></span><span class="comment"></span> </div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span><span class="comment">    /// Sets a callback for Client event updates which indicate status changes. Pass a `nullptr` value to remove a previously set callback.</span></div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span><span class="comment">    /// \n Usage: \code client-&gt;setClientEventCallback(std::bind(&amp;MyClass::onClientEvent, this, std::placeholders::_1)); \endcode</span></div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span><span class="comment">    /// This callback may be invoked from the main thread (where WASimClient was created), the dedicated &quot;dispatch&quot; thread the client maintains, or a temporary thread in one specific case when SimConnect sends a &quot;Quit&quot; command.</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span><span class="comment">    /// \sa ClientEventType, ClientEvent, WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span><span class="comment"></span>    <span class="keywordtype">void</span> setClientEventCallback(<a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#adf721d1a2e6d07f9b0d8b8557408cf6f">clientEventCallback_t</a> cb);<span class="comment"></span></div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span><span class="comment">    /// Same as `setClientEventCallback(clientEventCallback_t)`. Convenience for avoiding a std::bind expression.</span></div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span><span class="comment">    /// \n Usage: \code client-&gt;setClientEventCallback(&amp;MyClass::onClientEvent, this); \endcode \sa ClientEvent, WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span><span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> setClientEventCallback(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_client_event">ClientEvent</a> &amp;), Tcaller *<span class="keyword">const</span> caller);</div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span><span class="comment"></span> </div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span><span class="comment">    /// Sets a callback for list results arriving from the server. Pass a `nullptr` value to remove a previously set callback.</span></div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span><span class="comment">    /// \n Usage: \code client-&gt;setListResultsCallback(std::bind(&amp;MyClass::onListResult, this, std::placeholders::_1)); \endcode</span></div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span><span class="comment">    /// This callback is invoked from temporary thread which accumulates incoming list results until the listing is complete (or times out).</span></div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span><span class="comment">    /// Currently, only one pending list request can be active at any time, though this may change in the future.</span></div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span><span class="comment">    /// \sa ListResult, list(), \refwce{CommandId::List}, WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span><span class="comment"></span>    <span class="keywordtype">void</span> setListResultsCallback(<a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a58cba5c3dda6fb308904f9b238c4eef8">listResultsCallback_t</a> cb);<span class="comment"></span></div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span><span class="comment">    /// Same as `setListResultsCallback(listResultsCallback_t)`. Convenience for avoiding a `std::bind` expression.</span></div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span><span class="comment">    /// \n Usage: \code client-&gt;setListResultsCallback(&amp;MyClass::onListResult, this); \endcode \sa list(), \refwce{CommandId::List}, WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span><span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> setListResultsCallback(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_list_result">ListResult</a> &amp;), Tcaller *<span class="keyword">const</span> caller);</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span><span class="comment"></span> </div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span><span class="comment">    /// Sets a callback for value update data arriving from the server. Pass a `nullptr` value to remove a previously set callback.</span></div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span><span class="comment">    /// \n Usage: \code client-&gt;setDataCallback(std::bind(&amp;MyClass::onDataResult, this, std::placeholders::_1)); \endcode</span></div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span><span class="comment">    /// This callback is invoked from the dedicated &quot;dispatch&quot; thread the client maintains.</span></div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span><span class="comment">    /// \sa DataRequestRecord, saveDataRequest(), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span><span class="comment"></span>    <span class="keywordtype">void</span> setDataCallback(<a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a4e101c8c07197b490c3d1e2929f080a5">dataCallback_t</a> cb);<span class="comment"></span></div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span><span class="comment">    /// Same as `setDataCallback(dataCallback_t)`. Convenience overload template for avoiding a std::bind expression.</span></div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span><span class="comment">    /// \n Usage: \code client-&gt;setDataCallback(&amp;MyClass::onDataResult, this) \endcode \sa dataCallback_t, DataRequestRecord, saveDataRequest(), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span><span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> setDataCallback(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_data_request_record.html">DataRequestRecord</a> &amp;), Tcaller *<span class="keyword">const</span> caller);</div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span><span class="comment"></span> </div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span><span class="comment">    /// Sets a callback for logging activity, both from the server and the client itself. Pass a `nullptr` value to remove a previously set callback.</span></div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span><span class="comment">    /// \n Usage: \code client-&gt;setLogCallback(std::bind(&amp;MyClass::onLogMessage, this, std::placeholders::_1)); \endcode</span></div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span><span class="comment">    /// This callback may be invoked from either the main thread (where WASimClient was created), or the dedicated &quot;dispatch&quot; thread which the client maintains.</span></div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span><span class="comment">    /// \sa setLogLevel(), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span><span class="comment"></span>    <span class="keywordtype">void</span> setLogCallback(<a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a34b741f7fd40e861e389ae776b3c7de3">logCallback_t</a> cb);<span class="comment"></span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span><span class="comment">    /// Same as `setLogCallback(logCallback_t)`. Convenience template for avoiding a std::bind expression.</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span><span class="comment">    /// \n Usage: \code client-&gt;setLogCallback(&amp;MyClass::onLogMessage, this) \endcode  \sa setLogLevel(), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span><span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> setLogCallback(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_log_record.html">LogRecord</a> &amp;, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051">LogSource</a>), Tcaller *<span class="keyword">const</span> caller);</div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span><span class="comment"></span> </div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span><span class="comment">    /// Sets a callback for delivering command results returned by the server.  Pass a `nullptr` value to remove a previously set callback.</span></div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span><span class="comment">    /// While some of the high-level Client API calls do return an immediate status or result, many of the server commands are sent asynchronously, in a fire-and-forget fashion.</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span><span class="comment">    /// If you would like to be notified about _all_ command responses, set this callback. The `Command` type delivered will have the `Command::commandId` of type</span></div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span><span class="comment">    /// `CommandId::Ack` or `CommandId::Nak`. The `Command::uData` member is set to the `commandId` of the original command being responded to.</span></div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span><span class="comment">    /// Other `Command` struct members may have other meanings, depending on the actual command being responded to. See documentation for `WASimCommander::Enums::CommandId` for details.</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span><span class="comment">    /// \n Usage: \code client-&gt;setCommandResultCallback(std::bind(&amp;MyClass::onCommandResult, this, std::placeholders::_1)); \endcode</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span><span class="comment">    /// This callback is invoked from the dedicated &quot;dispatch&quot; thread the client maintains.</span></div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span><span class="comment">    /// \sa \refwce{CommandId}, WASimCommander::Command, WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span><span class="comment"></span>    <span class="keywordtype">void</span> setCommandResultCallback(<a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a68e29e00dcabb749657f695cf8f2c246">commandCallback_t</a> cb);<span class="comment"></span></div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span><span class="comment">    /// Same as `setCommandResultCallback(commandCallback_t)`. Convenience overload template for avoiding a std::bind expression.</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span><span class="comment">    /// \n Usage: \code client-&gt;setCommandResultCallback(&amp;MyClass::onCommandResult, this); \endcode \sa setCommandResultCallback(commandCallback_t), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span><span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> setCommandResultCallback(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;), Tcaller *<span class="keyword">const</span> caller);</div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span><span class="comment"></span> </div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span><span class="comment">    /// Sets a callback for delivering response commands sent to this client by the server module. Note that the server may also initiate a few types of commands (not in response to client commands)</span></div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span><span class="comment">    /// such as `Ping`, `List`, and `Disconnect`. In contrast to `setCommandResultCallback(commandCallback_t)`, this one will report on _all_ commands from the server, not just `Ack/Nak`.</span></div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span><span class="comment">    /// This callback is meant for low-level API usage.</span></div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span><span class="comment">    /// \n Usage: \code client-&gt;setResponseCallback(std::bind(&amp;MyClass::onServerResponse, this, std::placeholders::_1)); \endcode</span></div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span><span class="comment">    /// This callback is invoked from the dedicated &quot;dispatch&quot; thread the client maintains.</span></div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span><span class="comment">    /// \sa sendServerCommand(), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span><span class="comment"></span>    <span class="keywordtype">void</span> setResponseCallback(<a class="code hl_typedef" href="namespace_w_a_sim_commander_1_1_client.html#a68e29e00dcabb749657f695cf8f2c246">commandCallback_t</a> cb);<span class="comment"></span></div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span><span class="comment">    /// Same as `setResponseCallback(commandCallback_t)`. Convenience overload template for avoiding a std::bind expression.</span></div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span><span class="comment">    /// \n Usage: \code client-&gt;setResponseCallback(&amp;MyClass::onServerResponse, this); \endcode \sa setResponseCallback(responseCallback_t), WSMCMND_CLIENT_USE_CONCURRENT_CALLBACKS</span></div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span><span class="comment"></span>    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span>    <span class="keyword">inline</span> <span class="keywordtype">void</span> setResponseCallback(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;), Tcaller *<span class="keyword">const</span> caller);</div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span><span class="comment"></span> </div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span><span class="comment">    /// \}</span></div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span><span class="comment"></span> </div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>  <span class="keyword">private</span>:</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span>    <span class="keyword">class </span>Private;</div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span><span class="preprocessor">#pragma warning( suppress: 4251 )  </span><span class="comment">// &quot;warning C4251: ... needs to have dll-interface to be used by clients&quot; -- no client access here, safe to suppress</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>    <span class="keyword">const</span> std::unique_ptr&lt;Private&gt; d;</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span><span class="preprocessor">#ifndef DOXYGEN  </span><span class="comment">// insists on documenting this</span></div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span>    <span class="keyword">friend</span> <span class="keyword">class </span>Private;</div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span> </div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span>    <span class="comment">// we do not share well with others</span></div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span>    <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a>(<a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span>    <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a>(<span class="keyword">const</span> <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a> &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span>    <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a> &amp;operator=(<a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a>&amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span>    <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a> &amp;operator=(<span class="keyword">const</span> <a class="code hl_class" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimClient</a> &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span> </div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span>  };  <span class="comment">// WASimClient</span></div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span> </div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#adc84a90e0c460c0454fd35eed483c7b6">  581</a></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#af5abc2650cf635077f8c75810f89d2f3">WASimClient::setClientEventCallback</a>(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_client_event">ClientEvent</a> &amp;), Tcaller * <span class="keyword">const</span> caller)</div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span>  {</div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span>    <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#af5abc2650cf635077f8c75810f89d2f3">setClientEventCallback</a>(std::bind(member, caller, std::placeholders::_1));</div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>  }</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span> </div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a6ce95dd6797e1cb33c274abf3dd8d470">  587</a></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ac4bff1b37a1eb8d50c62c37e4abdb97a">WASimClient::setListResultsCallback</a>(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_list_result">ListResult</a> &amp;), Tcaller * <span class="keyword">const</span> caller)</div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>  {</div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span>    <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ac4bff1b37a1eb8d50c62c37e4abdb97a">setListResultsCallback</a>(std::bind(member, caller, std::placeholders::_1));</div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>  }</div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span> </div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a9981685b5b7a5c452daa9e3186290384">  593</a></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a1ddabb80726df8220e3a6ed4272bf737">WASimClient::setDataCallback</a>(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_client_1_1_data_request_record.html">DataRequestRecord</a> &amp;), Tcaller * <span class="keyword">const</span> caller)</div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span>  {</div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span>    <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a1ddabb80726df8220e3a6ed4272bf737">setDataCallback</a>(std::bind(member, caller, std::placeholders::_1));</div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span>  }</div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span> </div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#af8d12c7720493570322d39764f6220c8">  599</a></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a55dde5bc1f6406824138378f9f689e7a">WASimClient::setLogCallback</a>(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_log_record.html">LogRecord</a> &amp;, <a class="code hl_enumeration" href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051">LogSource</a>), Tcaller * <span class="keyword">const</span> caller)</div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span>  {</div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span>    <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a55dde5bc1f6406824138378f9f689e7a">setLogCallback</a>(std::bind(member, caller, std::placeholders::_1, std::placeholders::_2));</div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span>  }</div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span> </div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a06a6b5fc4ec0a35e1ff0c290f3e5d9a3">  605</a></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a9c6e16335bfa8a31859c87a7e008d9c6">WASimClient::setCommandResultCallback</a>(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;), Tcaller * <span class="keyword">const</span> caller)</div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span>  {</div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span>    <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a9c6e16335bfa8a31859c87a7e008d9c6">setCommandResultCallback</a>(std::bind(member, caller, std::placeholders::_1));</div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span>  }</div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span> </div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Tcaller&gt;</div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno"><a class="line" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#adff8d7cc90bb52c79cd052141ea185ab">  611</a></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#adeaf87a3c0a46b7fb971745ede3b92b9">WASimClient::setResponseCallback</a>(<span class="keywordtype">void</span>(__stdcall Tcaller::* <span class="keyword">const</span> member)(<span class="keyword">const</span> <a class="code hl_struct" href="struct_w_a_sim_commander_1_1_command.html">Command</a> &amp;), Tcaller * <span class="keyword">const</span> caller)</div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span>  {</div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span>    <a class="code hl_function" href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#adeaf87a3c0a46b7fb971745ede3b92b9">setResponseCallback</a>(std::bind(member, caller, std::placeholders::_1));</div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span>  }</div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span> </div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span>};  <span class="comment">// namespace WASimCommander::Client</span></div>
<div class="ttc" id="a_w_a_sim_commander_8h_html"><div class="ttname"><a href="_w_a_sim_commander_8h.html">WASimCommander.h</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html">WASimCommander::Client::WASimClient</a></div><div class="ttdoc">WASimCommander Client implementation. Handles all aspects of communication with the WASimCommander Se...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00084">WASimClient.h:85</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_a1ddabb80726df8220e3a6ed4272bf737"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a1ddabb80726df8220e3a6ed4272bf737">WASimCommander::Client::WASimClient::setDataCallback</a></div><div class="ttdeci">void setDataCallback(dataCallback_t cb)</div><div class="ttdoc">Sets a callback for value update data arriving from the server. Pass a nullptr value to remove a prev...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8cpp_source.html#l02082">WASimClient.cpp:2082</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_a55dde5bc1f6406824138378f9f689e7a"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a55dde5bc1f6406824138378f9f689e7a">WASimCommander::Client::WASimClient::setLogCallback</a></div><div class="ttdeci">void setLogCallback(logCallback_t cb)</div><div class="ttdoc">Sets a callback for logging activity, both from the server and the client itself. Pass a nullptr valu...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8cpp_source.html#l02083">WASimClient.cpp:2083</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_a5f0f7e3575c605a44516a407251567fe"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a5f0f7e3575c605a44516a407251567fe">WASimCommander::Client::WASimClient::setSimVarVariable</a></div><div class="ttdeci">HRESULT setSimVarVariable(const std::string &amp;variableName, const std::string &amp;unitName, double value)</div><div class="ttdoc">Sets a numeric value on an 'A' (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable....</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00262">WASimClient.h:262</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_a79b80707c04ebfd07c42b46abc753dfc"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a79b80707c04ebfd07c42b46abc753dfc">WASimCommander::Client::WASimClient::setSimVarVariable</a></div><div class="ttdeci">HRESULT setSimVarVariable(const std::string &amp;variableName, const std::string &amp;stringValue)</div><div class="ttdoc">Sets a string value on an 'A' (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable....</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00270">WASimClient.h:270</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_a9c6e16335bfa8a31859c87a7e008d9c6"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#a9c6e16335bfa8a31859c87a7e008d9c6">WASimCommander::Client::WASimClient::setCommandResultCallback</a></div><div class="ttdeci">void setCommandResultCallback(commandCallback_t cb)</div><div class="ttdoc">Sets a callback for delivering command results returned by the server. Pass a nullptr value to remove...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8cpp_source.html#l02084">WASimClient.cpp:2084</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_ac4bff1b37a1eb8d50c62c37e4abdb97a"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ac4bff1b37a1eb8d50c62c37e4abdb97a">WASimCommander::Client::WASimClient::setListResultsCallback</a></div><div class="ttdeci">void setListResultsCallback(listResultsCallback_t cb)</div><div class="ttdoc">Sets a callback for list results arriving from the server. Pass a nullptr value to remove a previousl...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8cpp_source.html#l02081">WASimClient.cpp:2081</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_ace0a22e5f77b43adf67e1b4642a1ed5c"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ace0a22e5f77b43adf67e1b4642a1ed5c">WASimCommander::Client::WASimClient::setSimVarVariable</a></div><div class="ttdeci">HRESULT setSimVarVariable(const std::string &amp;variableName, uint8_t index, const std::string &amp;unitName, double value)</div><div class="ttdoc">Sets a numeric value on an indexed 'A' (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable....</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00266">WASimClient.h:266</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_adeaf87a3c0a46b7fb971745ede3b92b9"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#adeaf87a3c0a46b7fb971745ede3b92b9">WASimCommander::Client::WASimClient::setResponseCallback</a></div><div class="ttdeci">void setResponseCallback(commandCallback_t cb)</div><div class="ttdoc">Sets a callback for delivering response commands sent to this client by the server module....</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8cpp_source.html#l02085">WASimClient.cpp:2085</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_ae3e6289323d9d13cbf928e0bbf521595"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#ae3e6289323d9d13cbf928e0bbf521595">WASimCommander::Client::WASimClient::setSimVarVariable</a></div><div class="ttdeci">HRESULT setSimVarVariable(const std::string &amp;variableName, uint8_t index, const std::string &amp;stringValue)</div><div class="ttdoc">Sets a string value on an indexed 'A' (aka &quot;SimVar&quot; / &quot;Simulator Variable&quot;) type variable....</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00274">WASimClient.h:274</a></div></div>
<div class="ttc" id="aclass_w_a_sim_commander_1_1_client_1_1_w_a_sim_client_html_af5abc2650cf635077f8c75810f89d2f3"><div class="ttname"><a href="class_w_a_sim_commander_1_1_client_1_1_w_a_sim_client.html#af5abc2650cf635077f8c75810f89d2f3">WASimCommander::Client::WASimClient::setClientEventCallback</a></div><div class="ttdeci">void setClientEventCallback(clientEventCallback_t cb)</div><div class="ttdoc">Sets a callback for Client event updates which indicate status changes. Pass a nullptr value to remov...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8cpp_source.html#l02080">WASimClient.cpp:2080</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html">WASimCommander::Client</a></div><div class="ttdoc">WASimCommander::Client namespace. Defines/declares everything needed to interact with the WASimComman...</div><div class="ttdef"><b>Definition:</b> <a href="client_2enums__impl_8h_source.html#l00031">enums_impl.h:32</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a23b8cf1733162a35a02159b38c3af217"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a23b8cf1733162a35a02159b38c3af217">WASimCommander::Client::E_TIMEOUT</a></div><div class="ttdeci">static const HRESULT E_TIMEOUT</div><div class="ttdoc">Error result: timeout communicating with server.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00059">WASimClient.h:59</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a34b741f7fd40e861e389ae776b3c7de3"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a34b741f7fd40e861e389ae776b3c7de3">WASimCommander::Client::logCallback_t</a></div><div class="ttdeci">std::function&lt; void __stdcall(const LogRecord &amp;, LogSource)&gt; logCallback_t</div><div class="ttdoc">Callback function for log entries (from both Client and Server).</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00075">WASimClient.h:75</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a4e101c8c07197b490c3d1e2929f080a5"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a4e101c8c07197b490c3d1e2929f080a5">WASimCommander::Client::dataCallback_t</a></div><div class="ttdeci">std::function&lt; void __stdcall(const DataRequestRecord &amp;)&gt; dataCallback_t</div><div class="ttdoc">Callback function for subscription result data.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00074">WASimClient.h:74</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a58cba5c3dda6fb308904f9b238c4eef8"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a58cba5c3dda6fb308904f9b238c4eef8">WASimCommander::Client::listResultsCallback_t</a></div><div class="ttdeci">std::function&lt; void __stdcall(const ListResult &amp;)&gt; listResultsCallback_t</div><div class="ttdoc">Callback function for delivering list results, eg. of local variables sent from Server.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00073">WASimClient.h:73</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a68e29e00dcabb749657f695cf8f2c246"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a68e29e00dcabb749657f695cf8f2c246">WASimCommander::Client::commandCallback_t</a></div><div class="ttdeci">std::function&lt; void __stdcall(const Command &amp;)&gt; commandCallback_t</div><div class="ttdoc">Callback function for commands sent from server.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00076">WASimClient.h:76</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a68f18cf1e63d23191b07bb2d2f5b8051"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051">WASimCommander::Client::LogSource</a></div><div class="ttdeci">LogSource</div><div class="ttdoc">Log entry source, Client or Server.</div><div class="ttdef"><b>Definition:</b> <a href="client_2enums__impl_8h_source.html#l00073">enums_impl.h:74</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_a68f18cf1e63d23191b07bb2d2f5b8051a577d7068826de925ea2aec01dbadf5e4"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#a68f18cf1e63d23191b07bb2d2f5b8051a577d7068826de925ea2aec01dbadf5e4">WASimCommander::Client::LogSource::Client</a></div><div class="ttdeci">@ Client</div><div class="ttdoc">Log record from WASimClient.</div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_aaed3e026d9bf1ef254d300587e4dbdb5"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#aaed3e026d9bf1ef254d300587e4dbdb5">WASimCommander::Client::E_NOT_CONNECTED</a></div><div class="ttdeci">static const HRESULT E_NOT_CONNECTED</div><div class="ttdoc">Error result: server not connected.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00056">WASimClient.h:56</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_ab1bd21185e813b2cdb9622bb49b34ff8"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#ab1bd21185e813b2cdb9622bb49b34ff8">WASimCommander::Client::CUSTOM_KEY_EVENT_ID_MIN</a></div><div class="ttdeci">static const uint32_t CUSTOM_KEY_EVENT_ID_MIN</div><div class="ttdoc">Starting ID range for &quot;Custom Key Events&quot; for use with registerCustomKeyEvent() generated IDs....</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00065">WASimClient.h:65</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_adf721d1a2e6d07f9b0d8b8557408cf6f"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#adf721d1a2e6d07f9b0d8b8557408cf6f">WASimCommander::Client::clientEventCallback_t</a></div><div class="ttdeci">std::function&lt; void __stdcall(const ClientEvent &amp;)&gt; clientEventCallback_t</div><div class="ttdoc">Callback function for Client events.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_client_8h_source.html#l00072">WASimClient.h:72</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_afd4f3e93b7e8dc26cd2d99ad61584521"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#afd4f3e93b7e8dc26cd2d99ad61584521">WASimCommander::Client::ClientStatus</a></div><div class="ttdeci">ClientStatus</div><div class="ttdoc">Client status flags.</div><div class="ttdef"><b>Definition:</b> <a href="client_2enums__impl_8h_source.html#l00035">enums_impl.h:36</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_struct_w_a_sim_commander_1_1_client_1_1_client_event"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_client_event">WASimCommander::Client::ClientEvent</a></div><div class="ttdoc">Client Event data, delivered via callback.</div><div class="ttdef"><b>Definition:</b> <a href="include_2client_2structs_8h_source.html#l00031">structs.h:32</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_client_html_struct_w_a_sim_commander_1_1_client_1_1_list_result"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_client.html#struct_w_a_sim_commander_1_1_client_1_1_list_result">WASimCommander::Client::ListResult</a></div><div class="ttdoc">Structure for delivering list results, eg. of local variables sent from Server.</div><div class="ttdef"><b>Definition:</b> <a href="include_2client_2structs_8h_source.html#l00041">structs.h:42</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_a7311e9d8f917bbcbb202497114e5f2c5"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#a7311e9d8f917bbcbb202497114e5f2c5">WASimCommander::Enums::LogLevel</a></div><div class="ttdeci">LogLevel</div><div class="ttdoc">Logging levels.</div><div class="ttdef"><b>Definition:</b> <a href="enums__impl_8h_source.html#l00154">enums_impl.h:155</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_ab1b85706615bc0e57fa6d8d464bf8a3d"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#ab1b85706615bc0e57fa6d8d464bf8a3d">WASimCommander::Enums::LookupItemType</a></div><div class="ttdeci">LookupItemType</div><div class="ttdoc">Types of things to look up or list.</div><div class="ttdef"><b>Definition:</b> <a href="enums__impl_8h_source.html#l00135">enums_impl.h:136</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_ab1b85706615bc0e57fa6d8d464bf8a3da89179ec269c2cab46e905f38ae8978cb"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#ab1b85706615bc0e57fa6d8d464bf8a3da89179ec269c2cab46e905f38ae8978cb">WASimCommander::Enums::LookupItemType::LocalVariable</a></div><div class="ttdeci">@ LocalVariable</div><div class="ttdoc">LVar ('L') names and IDs. Available for List and Lookup commands.</div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_ac056a41f7fdbf2fb2599ad86c3949922"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#ac056a41f7fdbf2fb2599ad86c3949922">WASimCommander::Enums::CalcResultType</a></div><div class="ttdeci">CalcResultType</div><div class="ttdoc">The type of result that calculator code is expected to produce.</div><div class="ttdef"><b>Definition:</b> <a href="enums__impl_8h_source.html#l00108">enums_impl.h:109</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_ac056a41f7fdbf2fb2599ad86c3949922a6adf97f83acf6453d4a6a4b1070f3754"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#ac056a41f7fdbf2fb2599ad86c3949922a6adf97f83acf6453d4a6a4b1070f3754">WASimCommander::Enums::CalcResultType::None</a></div><div class="ttdeci">@ None</div><div class="ttdoc">No result is expected (eg. triggering an event).</div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_af3131943610c59d71d8b69dd7b2cab97"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#af3131943610c59d71d8b69dd7b2cab97">WASimCommander::Enums::LogFacility</a></div><div class="ttdeci">LogFacility</div><div class="ttdoc">Logging destination type.</div><div class="ttdef"><b>Definition:</b> <a href="enums__impl_8h_source.html#l00170">enums_impl.h:171</a></div></div>
<div class="ttc" id="anamespace_w_a_sim_commander_1_1_enums_html_af3131943610c59d71d8b69dd7b2cab97af8508f576cd3f742dfc268258dcdf0dd"><div class="ttname"><a href="namespace_w_a_sim_commander_1_1_enums.html#af3131943610c59d71d8b69dd7b2cab97af8508f576cd3f742dfc268258dcdf0dd">WASimCommander::Enums::LogFacility::Remote</a></div><div class="ttdeci">@ Remote</div><div class="ttdoc">Remote destination, eg. network transmission or a callback event.</div></div>
<div class="ttc" id="astruct_w_a_sim_commander_1_1_client_1_1_data_request_record_html"><div class="ttname"><a href="struct_w_a_sim_commander_1_1_client_1_1_data_request_record.html">WASimCommander::Client::DataRequestRecord</a></div><div class="ttdoc">DataRequestRecord inherits and extends WASimCommander::DataRequest with data pertinent for use by a d...</div><div class="ttdef"><b>Definition:</b> <a href="include_2client_2structs_8h_source.html#l00069">structs.h:70</a></div></div>
<div class="ttc" id="astruct_w_a_sim_commander_1_1_client_1_1_registered_event_html"><div class="ttname"><a href="struct_w_a_sim_commander_1_1_client_1_1_registered_event.html">WASimCommander::Client::RegisteredEvent</a></div><div class="ttdoc">Structure to hold data for registered (reusable) calculator events. Used to submit events with WASimC...</div><div class="ttdef"><b>Definition:</b> <a href="include_2client_2structs_8h_source.html#l00149">structs.h:150</a></div></div>
<div class="ttc" id="astruct_w_a_sim_commander_1_1_client_1_1_variable_request_html"><div class="ttname"><a href="struct_w_a_sim_commander_1_1_client_1_1_variable_request.html">WASimCommander::Client::VariableRequest</a></div><div class="ttdoc">Structure for using with WASimClient::getVariable() and WASimClient::setVariable() to specify informa...</div><div class="ttdef"><b>Definition:</b> <a href="include_2client_2structs_8h_source.html#l00109">structs.h:110</a></div></div>
<div class="ttc" id="astruct_w_a_sim_commander_1_1_command_html"><div class="ttname"><a href="struct_w_a_sim_commander_1_1_command.html">WASimCommander::Command</a></div><div class="ttdoc">Command data structure. The member contents depend on the command type as described in each command t...</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_commander_8h_source.html#l00098">WASimCommander.h:99</a></div></div>
<div class="ttc" id="astruct_w_a_sim_commander_1_1_data_request_html"><div class="ttname"><a href="struct_w_a_sim_commander_1_1_data_request.html">WASimCommander::DataRequest</a></div><div class="ttdoc">Structure for variable value subscription requests.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_commander_8h_source.html#l00127">WASimCommander.h:128</a></div></div>
<div class="ttc" id="astruct_w_a_sim_commander_1_1_log_record_html"><div class="ttname"><a href="struct_w_a_sim_commander_1_1_log_record.html">WASimCommander::LogRecord</a></div><div class="ttdoc">Log record structure.</div><div class="ttdef"><b>Definition:</b> <a href="_w_a_sim_commander_8h_source.html#l00250">WASimCommander.h:251</a></div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.4-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_46e873e9de9fedca8b86b802c8909ebf.html">client</a></li><li class="navelem"><a class="el" href="_w_a_sim_client_8h.html">WASimClient.h</a></li>
    <li class="footer">Generated for WASimCommander &#160;v1.3.1.0 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
